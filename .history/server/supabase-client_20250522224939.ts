import { SupabaseClient, createClient } from '@supabase/supabase-js'; 
import type {
  User, InsertUser, UpdateUser, Section, InsertSection, UpdateSection,
  Project, InsertProject, UpdateProject,
  Experience, InsertExperience, UpdateExperience,
  Certification, InsertCertification, UpdateCertification,
  BlogPost, InsertBlogPost, UpdateBlogPost,
  BlogCategory, InsertBlogCategory, UpdateBlogCategory, BlogSubscription, InsertBlogSubscription, UpdateBlogSubscription,
  CaseStudyDetail, InsertCaseStudyDetail, UpdateCaseStudyDetail, ContactSubmission, InsertContactSubmission, UpdateContactSubmission,
  IStorage
} from '../shared/schema';
import { UserRole } from '../shared/schema';
import type { Database } from '../shared/database.types';
import { SectionType, BlogPostStatus } from '../shared/types'; 
import { ReturnTypeMap } from '../shared/schema'; // Added import for ReturnTypeMap

// Define the database tables type
type DBTables = Database['public']['Tables'];

// Define the return type map
type ReturnTypeMap = {
  users: any;
  blog_posts: any;
  case_study_details: any;
  certifications: any;
  contact_submissions: any;
  experiences: any;
  profiles: any;
  projects: any;
  sections: any;
};

// Define the Json type
type Json = string | number | boolean | null | { [key: string]: Json | undefined } | Json[];

// Create a singleton instance of the Supabase client
let supabaseClient: ReturnType<typeof createClient<Database>> | null = null;

export function getSupabaseClientInstance() {
  if (!supabaseClient) {
    const supabaseUrl = process.env['SUPABASE_URL'];
    const supabaseKey = process.env['SUPABASE_SERVICE_ROLE_KEY'];

    if (!supabaseUrl || !supabaseKey) {
      throw new Error('Missing Supabase credentials');
    }

    supabaseClient = createClient<Database>(supabaseUrl, supabaseKey);
  }

  return supabaseClient;
}

// Alias for database table types
type TableName = keyof DBTables;

// Generic type for table operations
type TableOperation<T extends TableName> = {
  table: T;
  data: Database['public']['Tables'][T]['Insert'];
  id?: string;
};

// Generic function to handle table operations
export async function handleTableOperation<T extends TableName>({
  table,
  data,
  id,
}: TableOperation<T>) {
  const supabase = getSupabaseClientInstance();

  if (id) {
    const { data: result, error } = await supabase
      .from(table)
      .update(data)
      .eq('id', id)
      .select()
      .single();

    if (error) throw error;
    return result;
  } else {
    const { data: result, error } = await supabase
      .from(table)
      .insert(data)
      .select()
      .single();

    if (error) throw error;
    return result;
  }
}

// User operations
export async function createUser(email: string) {
  const id = crypto.randomUUID();
  return handleTableOperation({
    table: 'users',
    data: { id, email },
  });
}

export async function updateUser(id: string, data: Database['public']['Tables']['users']['Update']) {
  return handleTableOperation({
    table: 'users',
    data,
    id,
  });
}

// Blog post operations
export async function createBlogPost(data: Database['public']['Tables']['blog_posts']['Insert']) {
  return handleTableOperation({
    table: 'blog_posts',
    data,
  });
}

export async function updateBlogPost(
  id: string,
  data: Database['public']['Tables']['blog_posts']['Update']
) {
  return handleTableOperation({
    table: 'blog_posts',
    data,
    id,
  });
}

// Case study operations
export async function createCaseStudy(data: Database['public']['Tables']['case_study_details']['Insert']) {
  return handleTableOperation({
    table: 'case_study_details',
    data,
  });
}

export async function updateCaseStudy(
  id: string,
  data: Database['public']['Tables']['case_study_details']['Update']
) {
  return handleTableOperation({
    table: 'case_study_details',
    data,
    id,
  });
}

// Contact submission operations
export async function createContactSubmission(
  data: Database['public']['Tables']['contact_submissions']['Insert']
) {
  return handleTableOperation({
    table: 'contact_submissions',
    data,
  });
}

export async function updateContactSubmission(
  id: string,
  data: Database['public']['Tables']['contact_submissions']['Update']
) {
  return handleTableOperation({
    table: 'contact_submissions',
    data,
    id,
  });
}

// --- Mapper Utility --- 
function parseJsonIfNeeded<T>(content: string | T | null | undefined): T | undefined {
  if (typeof content === 'string') {
    try {
      return JSON.parse(content) as T;
    } catch (e) {
      console.warn('Failed to parse JSON content', content, e);
      return undefined; 
    }
  }
  return content as T ?? undefined;
}

// --- Mapper Functions --- 

// USER
export const mapUserToSupabaseInsert = (
  user: InsertUser
): DBTables['users']['Insert'] => {
  // id is typically auto-generated by auth trigger or should be explicitly passed if linking
  const insertData: DBTables['users']['Insert'] = {
    email: user.email,
    // Supabase handles created_at, updated_at. id comes from auth.users typically.
  };
  if (user.id) {
    insertData.id = user.id; // Allow specifying if known (e.g. from auth response)
  }
  return insertData;
};

export const mapUserToSupabaseUpdate = (
  user: Partial<UpdateUser | User> // Allow full User for convenience, map relevant fields
): DBTables['users']['Update'] => {
  const updateData: DBTables['users']['Update'] = {};
  if (user.email !== undefined) updateData.email = user.email;
  // Supabase handles updated_at
  // Other fields from User model that can be updated and exist in DBTables['users']['Update']
  // e.g., if (user.firstName !== undefined) updateData.first_name = user.firstName;
  return updateData;
};

export const mapSupabaseToUser = (row: DBTables['users']['Row']): User => {
  return {
    id: row.id,
    email: row.email as string,
    username: row.email?.split('@')[0] || '', 
    created_at: row.created_at ? new Date(row.created_at) : new Date(),
    updated_at: row.updated_at ? new Date(row.updated_at) : new Date(),
    firstName: undefined,
    lastName: undefined,
    avatar: undefined,
    bio: undefined,
    role: UserRole.USER, 
    emailVerified: false, 
  };
};

// SECTION
export const mapSectionToSupabaseInsert = (
  section: InsertSection
): DBTables['sections']['Insert'] => {
  return {
    user_id: section.userId,
    title: section.title,
    type: section.type as string, // Cast if SectionType and DB enum differ
    subtitle: section.subtitle,
    content: JSON.stringify(section.content), // Ensure content is stringified JSON
    order: section.order,
    is_visible: section.isVisible,
    // created_at, updated_at managed by DB
  };
};

export const mapSectionToSupabaseUpdate = (
  section: Partial<UpdateSection>
): DBTables['sections']['Update'] => {
  const updateData: DBTables['sections']['Update'] = {};
  if (section.userId !== undefined) updateData.user_id = section.userId;
  if (section.title !== undefined) updateData.title = section.title;
  if (section.type !== undefined) updateData.type = section.type as string;
  if (section.subtitle !== undefined) updateData.subtitle = section.subtitle;
  if (section.content !== undefined) updateData.content = JSON.stringify(section.content);
  if (section.order !== undefined) updateData.order = section.order;
  if (section.isVisible !== undefined) updateData.is_visible = section.isVisible;
  // updated_at managed by DB
  return updateData;
};

export const mapSupabaseToSection = (row: DBTables['sections']['Row']): Section => {
  return {
    id: row.id,
    userId: '', // userId is not in DB 'sections' table as per Memory 475f8931
    type: row.type as SectionType,
    title: row.title as string,
    subtitle: null, 
    content: parseJsonIfNeeded<Record<string, unknown>>(row.content) || {},
    order: 0, 
    isVisible: true, 
    created_at: new Date(row.created_at as string),
    updated_at: new Date(row.updated_at as string),
  };
};

// PROJECT
export const mapProjectToSupabaseInsert = (
  project: InsertProject
): DBTables['projects']['Insert'] => {
  const insertData: DBTables['projects']['Insert'] = {
    user_id: project.userId,
    title: project.title,
    description: project.description,
    is_featured: project.featured,
    order: project.order,
  };
  if (project.imageUrl !== undefined) insertData.featured_image = project.imageUrl;
  if (project.projectUrl !== undefined) insertData.demo_url = project.projectUrl;
  if (project.githubUrl !== undefined) insertData.github_url = project.githubUrl;
  if (project.category !== undefined) insertData.category = project.category;
  if (project.tags !== undefined) insertData.tags = project.tags;
  if (project.featuredOrder !== undefined) insertData.featured_order = project.featuredOrder;
  return insertData;
};

export const mapProjectToSupabaseUpdate = (
  project: Partial<UpdateProject>
): DBTables['projects']['Update'] => {
  const updateData: DBTables['projects']['Update'] = {};
  if (project.userId !== undefined) updateData.user_id = project.userId;
  if (project.title !== undefined) updateData.title = project.title;
  if (project.description !== undefined) updateData.description = project.description;
  if (project.imageUrl !== undefined) updateData.featured_image = project.imageUrl;
  if (project.projectUrl !== undefined) updateData.demo_url = project.projectUrl;
  if (project.githubUrl !== undefined) updateData.github_url = project.githubUrl;
  if (project.category !== undefined) updateData.category = project.category;
  if (project.tags !== undefined) updateData.tags = project.tags;
  if (project.featured !== undefined) updateData.is_featured = project.featured;
  if (project.featuredOrder !== undefined) updateData.featured_order = project.featuredOrder;
  if (project.order !== undefined) updateData.order = project.order;
  return updateData;
};

export const mapSupabaseToProject = (row: DBTables['projects']['Row']): Project => {
  return {
    id: row.id as string,
    userId: row.user_id as string,
    title: row.title as string,
    description: row.description as string,
    imageUrl: row.featured_image ?? null,
    projectUrl: row.demo_url ?? null,
    githubUrl: row.github_url ?? null,
    featured: row.is_featured as boolean,
    created_at: new Date(row.created_at as string),
    updated_at: new Date(row.updated_at as string),
    category: (row as any).category ?? null,
    tags: (row as any).tags ?? undefined,
    order: (row as any).order ?? 0,
    featuredOrder: (row as any).featured_order ?? undefined,
  };
};

// EXPERIENCE
export const mapSupabaseToExperience = (row: DBTables['experiences']['Row']): Experience => {
  return {
    id: row.id,
    userId: '', // userId is not in DB 'experiences' table as per Memory 475f8931
    title: row.title || '',
    company: row.company || '',
    location: row.location || '',
    startDate: row.start_date ? new Date(row.start_date) : new Date(), 
    endDate: row.end_date ? new Date(row.end_date) : null, 
    description: row.description || '',
    created_at: row.created_at ? new Date(row.created_at) : new Date(), 
    updated_at: row.updated_at ? new Date(row.updated_at) : new Date(), 
  };
};

export const mapExperienceToSupabaseInsert = (
  experience: InsertExperience
): DBTables['experiences']['Insert'] => {
  // Per Memory 475f8931, 'experiences' table has no user_id. Domain model has userId.
  // We will not map userId to the database for insert/update.
  const insertData: DBTables['experiences']['Insert'] = {
    title: experience.title,
    company: experience.company,
    location: experience.location,
    start_date: experience.startDate.toISOString().split('T')[0],
    description: experience.description,
  };
  if (experience.endDate) {
    insertData.end_date = experience.endDate.toISOString().split('T')[0];
  }
  // created_at, updated_at managed by DB
  // id is auto-increment
  return insertData;
};

export const mapExperienceToSupabaseUpdate = (
  experience: Partial<UpdateExperience>
): DBTables['experiences']['Update'] => {
  const updateData: DBTables['experiences']['Update'] = {};
  if (experience.title !== undefined) updateData.title = experience.title;
  if (experience.company !== undefined) updateData.company = experience.company;
  if (experience.location !== undefined) updateData.location = experience.location;
  if (experience.startDate !== undefined) updateData.start_date = experience.startDate.toISOString().split('T')[0];
  if (experience.endDate !== undefined) updateData.end_date = experience.endDate ? experience.endDate.toISOString().split('T')[0] : null;
  if (experience.description !== undefined) updateData.description = experience.description;
  // updated_at managed by DB
  return updateData;
};

// CERTIFICATION
export const mapCertificationToSupabaseInsert = (
  cert: InsertCertification
): DBTables['certifications']['Insert'] => {
  const insertData: DBTables['certifications']['Insert'] = {
    user_id: cert.userId,
    name: cert.name,
    issuer: cert.issuingOrganization,
    issue_date: cert.issueDate instanceof Date ? cert.issueDate.toISOString().split('T')[0] : cert.issueDate,
  };
  if (cert.expirationDate !== undefined) insertData.expiration_date = cert.expirationDate instanceof Date ? cert.expirationDate.toISOString().split('T')[0] : cert.expirationDate;
  if (cert.credentialID !== undefined) insertData.credential_id = cert.credentialID;
  if (cert.credentialURL !== undefined) insertData.credential_url = cert.credentialURL;
  if (cert.featured !== undefined) insertData.featured = cert.featured;
  if (cert.imageUrl !== undefined) insertData.image_url = cert.imageUrl;
  if (cert.order !== undefined) insertData.order = cert.order;
  return insertData;
};

export const mapCertificationToSupabaseUpdate = (
  cert: Partial<UpdateCertification>
): DBTables['certifications']['Update'] => {
  const updateData: DBTables['certifications']['Update'] = {};
  if (cert.userId !== undefined) updateData.user_id = cert.userId;
  if (cert.name !== undefined) updateData.name = cert.name;
  if (cert.issuingOrganization !== undefined) updateData.issuer = cert.issuingOrganization;
  if (cert.issueDate !== undefined) updateData.issue_date = cert.issueDate instanceof Date ? cert.issueDate.toISOString().split('T')[0] : cert.issueDate;
  if (cert.expirationDate !== undefined) updateData.expiration_date = cert.expirationDate instanceof Date ? cert.expirationDate.toISOString().split('T')[0] : cert.expirationDate;
  else if (cert.expirationDate === null) updateData.expiration_date = null;
  if (cert.credentialID !== undefined) updateData.credential_id = cert.credentialID;
  if (cert.credentialURL !== undefined) updateData.credential_url = cert.credentialURL;
  if (cert.featured !== undefined) updateData.featured = cert.featured;
  if (cert.imageUrl !== undefined) updateData.image_url = cert.imageUrl;
  if (cert.order !== undefined) updateData.order = cert.order;
  return updateData;
};

export const mapSupabaseToCertification = (row: DBTables['certifications']['Row']): Certification => {
  return {
    id: row.id as string,
    userId: row.user_id as string,
    name: row.name as string,
    issuingOrganization: row.issuer as string,
    issueDate: new Date(row.issue_date as string),
    expirationDate: row.expiration_date ? new Date(row.expiration_date as string) : null,
    credentialID: row.credential_id ?? null,
    credentialURL: row.credential_url ?? null,
    created_at: new Date(row.created_at as string),
    updated_at: new Date(row.updated_at as string),
    featured: (row as any).featured ?? undefined,
    imageUrl: (row as any).image_url ?? null,
    order: (row as any).order ?? undefined,
  };
};

// BLOGPOST
export const mapBlogPostToSupabaseInsert = (
  post: InsertBlogPost
): DBTables['blog_posts']['Insert'] => {
  const insertData: DBTables['blog_posts']['Insert'] = {
    category_id: post.categoryId,
    title: post.title,
    slug: post.slug,
    content: post.content,
    publish_date: post.publishDate instanceof Date ? post.publishDate.toISOString() : post.publishDate,
    status: post.status as string,
    is_published: post.isPublished,
  };
  if (post.userId !== undefined) insertData.author_id = post.userId;
  if (post.excerpt !== undefined) insertData.excerpt = post.excerpt;
  if (post.featuredImage !== undefined) insertData.featured_image = post.featuredImage;
  if (post.tags !== undefined) insertData.tags = post.tags;
  return insertData;
};

export const mapBlogPostToSupabaseUpdate = (
  post: Partial<UpdateBlogPost>
): DBTables['blog_posts']['Update'] => {
  const updateData: DBTables['blog_posts']['Update'] = {};
  if (post.userId !== undefined) updateData.author_id = post.userId;
  if (post.categoryId !== undefined) updateData.category_id = post.categoryId;
  if (post.title !== undefined) updateData.title = post.title;
  if (post.slug !== undefined) updateData.slug = post.slug;
  if (post.content !== undefined) updateData.content = post.content;
  if (post.excerpt !== undefined) updateData.excerpt = post.excerpt;
  if (post.featuredImage !== undefined) updateData.featured_image = post.featuredImage;
  if (post.publishDate !== undefined) updateData.publish_date = post.publishDate instanceof Date ? post.publishDate.toISOString() : post.publishDate;
  if (post.status !== undefined) updateData.status = post.status as string;
  if (post.isPublished !== undefined) updateData.is_published = post.isPublished;
  if (post.tags !== undefined) updateData.tags = post.tags;
  return updateData;
};

export const mapSupabaseToBlogPost = (row: DBTables['blog_posts']['Row']): BlogPost => {
  const publishDate = row.publish_date ? new Date(row.publish_date as string) : new Date();
  const status = row.status as BlogPostStatus;
  return {
    id: row.id as number,
    userId: row.author_id ?? null,
    categoryId: row.category_id as number,
    title: row.title as string,
    slug: row.slug as string,
    content: row.content as string,
    excerpt: row.excerpt ?? null,
    featuredImage: row.featured_image ?? null,
    publishDate: publishDate,
    status: status,
    isPublished: status === BlogPostStatus.PUBLISHED && publishDate <= new Date(),
    tags: parseJsonIfNeeded<string[]>(row.tags) ?? undefined,
    created_at: new Date(row.created_at as string),
    updated_at: new Date(row.updated_at as string),
  };
};

// Helper function to get domain mapper
export function getDomainMapper<T_DB extends keyof ReturnTypeMap>(
  table: T_DB
): ((row: DBTables[T_DB]['Row']) => ReturnTypeMap[T_DB]) | undefined {
  switch (table) {
    case 'users':
      return mapSupabaseToUser as any;
    case 'profiles': // Added profiles case
      return mapSupabaseToUser as any; // Assuming Profile domain type is User and maps to users table
    case 'sections':
      return mapSupabaseToSection as any;
    case 'projects':
      return mapSupabaseToProject as any;
    case 'experiences':
      return mapSupabaseToExperience as any;
    case 'certifications':
      return mapSupabaseToCertification as any;
    case 'blog_posts':
      return mapSupabaseToBlogPost as any;
    case 'blog_categories':
      return mapSupabaseToBlogCategory as any;
    case 'case_study_details':
      return mapSupabaseToCaseStudyDetail as any;
    case 'contact_submissions':
      return mapSupabaseToContactSubmission as any; 
    // Add other mappers here as needed
    default:
      // const _exhaustiveCheck: never = table; // This will error if switch isn't exhaustive for ReturnTypeMap keys
      // return undefined;
      // Ensure _exhaustiveCheck is used to satisfy linters and provide a runtime error
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const exhaustiveCheck: never = table; 
      throw new Error(`Non-exhaustive switch in getDomainMapper: unhandled table ${String(exhaustiveCheck)}`);
  }
}

// Placeholder mappers - define or import properly later
export const mapSupabaseToBlogCategory = (row: DBTables['blog_categories']['Row']): BlogCategory => {
  return row as any; // TODO: Define proper mapping for BlogCategory
};
export const mapSupabaseToCaseStudyDetail = (row: DBTables['case_study_details']['Row']): CaseStudyDetail => {
  return row as any; // TODO: Define proper mapping for CaseStudyDetail
};
export const mapSupabaseToContactSubmission = (row: DBTables['contact_submissions']['Row']): ContactSubmission => {
  return row as any; // TODO: Define proper mapping for ContactSubmission
};

// BLOG CATEGORY MAPPERS (Domain to Supabase)
export const mapBlogCategoryToSupabaseInsert = (
  category: InsertBlogCategory
): DBTables['blog_categories']['Insert'] => {
  return {
    name: category.name,
    slug: category.slug,
    description: category.description,
  };
};

export const mapBlogCategoryToSupabaseUpdate = (
  category: Partial<UpdateBlogCategory>
): DBTables['blog_categories']['Update'] => {
  const updateData: DBTables['blog_categories']['Update'] = {};
  if (category.name !== undefined) updateData.name = category.name;
  if (category.slug !== undefined) updateData.slug = category.slug;
  if (category.description !== undefined) updateData.description = category.description;
  return updateData;
};

// BLOG SUBSCRIPTION MAPPERS (Supabase to Domain is TBD, Domain to Supabase)
export const mapSupabaseToBlogSubscription = (row: DBTables['blog_subscriptions']['Row']): BlogSubscription => {
  return row as any; // TODO: Define proper mapping
};

export const mapBlogSubscriptionToSupabaseInsert = (
  subscription: InsertBlogSubscription
): DBTables['blog_subscriptions']['Insert'] => {
  return {
    email: subscription.email,
    status: subscription.status,
    confirmed: subscription.confirmed,
    confirmation_token: subscription.confirmationToken,
    // subscribed_at, updated_at managed by DB or specific logic
  };
};

export const mapBlogSubscriptionToSupabaseUpdate = (
  subscription: Partial<UpdateBlogSubscription>
): DBTables['blog_subscriptions']['Update'] => {
  const updateData: DBTables['blog_subscriptions']['Update'] = {};
  if (subscription.email !== undefined) updateData.email = subscription.email;
  if (subscription.status !== undefined) updateData.status = subscription.status;
  if (subscription.confirmed !== undefined) updateData.confirmed = subscription.confirmed;
  if (subscription.confirmationToken !== undefined) updateData.confirmation_token = subscription.confirmationToken;
  if (subscription.unsubscribedAt !== undefined) updateData.unsubscribed_at = subscription.unsubscribedAt?.toISOString();
  return updateData;
};

// CASE STUDY DETAIL MAPPERS (Supabase to Domain is placeholder, Domain to Supabase)
export const mapCaseStudyDetailToSupabaseInsert = (
  detail: InsertCaseStudyDetail
): DBTables['case_study_details']['Insert'] => {
  const { blogPostId, title, slug, client, role, duration, technologies, problem, solution, results, challenges, learnings, testimonial, metrics, gallery, galleryImages, images, videoUrl, projectType, relatedProjectIds, featured, featuredOrder, relatedPosts, externalLinks, seoKeywords, seoDescription } = detail;
  // This is a complex object, ensure all fields match DB schema
  // For simplicity, mapping only a few fields, extend as needed.
  return {
    blog_post_id: blogPostId,
    title,
    slug,
    client,
    technologies: technologies as Json, // Assuming technologies is stored as JSONB
    problem,
    solution,
    results,
    featured: featured ?? false,
    // Map other fields from InsertCaseStudyDetail to DBTables['case_study_details']['Insert']
    // Example: role: role,
  } as DBTables['case_study_details']['Insert']; // Cast needed if not all fields are explicitly mapped
};

export const mapCaseStudyDetailToSupabaseUpdate = (
  detail: Partial<UpdateCaseStudyDetail>
): DBTables['case_study_details']['Update'] => {
  const updateData: DBTables['case_study_details']['Update'] = {};
  if (detail.blogPostId !== undefined) updateData.blog_post_id = detail.blogPostId;
  if (detail.title !== undefined) updateData.title = detail.title;
  if (detail.slug !== undefined) updateData.slug = detail.slug;
  if (detail.client !== undefined) updateData.client = detail.client;
  if (detail.technologies !== undefined) updateData.technologies = detail.technologies as Json;
  if (detail.problem !== undefined) updateData.problem = detail.problem;
  if (detail.solution !== undefined) updateData.solution = detail.solution;
  if (detail.results !== undefined) updateData.results = detail.results;
  if (detail.featured !== undefined) updateData.featured = detail.featured;
  // Map other fields...
  return updateData;
};

// CONTACT SUBMISSION MAPPERS (Supabase to Domain is placeholder, Domain to Supabase)
export const mapContactSubmissionToSupabaseInsert = (
  submission: InsertContactSubmission
): DBTables['contact_submissions']['Insert'] => {
  // Assuming InsertContactSubmission has name, email, subject, message, status
  return {
    name: submission.name,
    email: submission.email,
    subject: submission.subject,
    message: submission.message,
    status: submission.status ?? 'pending', // Default status
  } as DBTables['contact_submissions']['Insert'];
};

export const mapContactSubmissionToSupabaseUpdate = (
  submission: Partial<UpdateContactSubmission>
): DBTables['contact_submissions']['Update'] => {
  const updateData: DBTables['contact_submissions']['Update'] = {};
  if (submission.name !== undefined) updateData.name = submission.name;
  if (submission.email !== undefined) updateData.email = submission.email;
  if (submission.subject !== undefined) updateData.subject = submission.subject;
  if (submission.message !== undefined) updateData.message = submission.message;
  if (submission.status !== undefined) updateData.status = submission.status;
  return updateData;
};

// --- SupabaseStorage Implementation --- 
export class SupabaseStorage implements IStorage {
  private client: SupabaseClient<Database>;

  constructor() {
    this.client = getSupabaseClientInstance();
  }

  // Generic, low-level methods from IStorage that deal with raw DB types
  // These methods remain unchanged as they correctly expect raw Supabase DB types after mappers are applied by callers
  async findById<T_DB extends keyof ReturnTypeMap>(
    table: T_DB,
    id: number | string
  ): Promise<ReturnTypeMap[T_DB] | null> {
    const { data, error } = await this.client.from(table).select('*').eq('id', id).single();

    if (error && error.code !== 'PGRST116') { // PGRST116: 'Not found'
      console.error(`Error finding ${table} by id ${id}:`, error);
      // Optionally, rethrow or handle specific errors
      throw new Error(`Supabase error: ${error.message}`);
    }
    if (!data) return null;

    const mapper = getDomainMapper(table);
    return mapper ? mapper(data as any) : (data as any); // Fallback to raw data if no mapper
  }

  async findAll<T_DB extends keyof ReturnTypeMap>(
    table: T_DB
  ): Promise<ReturnTypeMap[T_DB][]> {
    const { data, error } = await this.client.from(table).select('*');

    if (error) {
      console.error(`Error finding all ${table}:`, error);
      throw new Error(`Supabase error: ${error.message}`);
    }
    if (!data) return [];

    const mapper = getDomainMapper(table);
    return data.map(item => (mapper ? mapper(item as any) : (item as any)));
  }

  async findAllByField<T_DB extends keyof ReturnTypeMap, T_Field extends keyof DBTables[T_DB]['Row']>(
    table: T_DB,
    field: T_Field, 
    value: DBTables[T_DB]['Row'][T_Field]
  ): Promise<ReturnTypeMap[T_DB][]> {
    const { data, error } = await this.client.from(table).select('*').eq(field as string, value);

    if (error) {
      console.error(`Error finding all ${table} by ${String(field)} = ${value}:`, error);
      throw new Error(`Supabase error: ${error.message}`);
    }
    if (!data) return [];

    const mapper = getDomainMapper(table);
    return data.map(item => (mapper ? mapper(item as any) : (item as any)));
  }

  async create<T_DB extends keyof ReturnTypeMap>(
    table: T_DB,
    // This 'item' is now expected to be the direct Supabase Insert type
    item: DBTables[T_DB]['Insert'] 
  ): Promise<ReturnTypeMap[T_DB] | null> {
    const { data, error } = await this.client.from(table).insert(item as any).select().single();

    if (error) {
      console.error(`Error creating ${table}:`, error);
      // Consider more specific error handling or rethrowing
      throw new Error(`Supabase error creating ${table}: ${error.message}`);
    }
    if (!data) return null;

    const mapper = getDomainMapper(table);
    return mapper ? mapper(data as any) : (data as any);
  }

  async update<T_DB extends keyof ReturnTypeMap>(
    table: T_DB,
    id: number | string,
    // This 'item' is now expected to be the direct Supabase Update type
    item: DBTables[T_DB]['Update']
  ): Promise<ReturnTypeMap[T_DB] | null> {
    const { data, error } = await this.client.from(table).update(item as any).eq('id', id).select().single();

    if (error) {
      console.error(`Error updating ${table} with id ${id}:`, error);
      throw new Error(`Supabase error updating ${table}: ${error.message}`);
    }
    if (!data) return null;

    const mapper = getDomainMapper(table);
    return mapper ? mapper(data as any) : (data as any);
  }

  async delete<T_DB extends keyof ReturnTypeMap>(table: T_DB, id: number | string): Promise<boolean> {
    const { error } = await this.client.from(table).delete().eq('id', id);

    if (error) {
      console.error(`Error deleting ${table} with id ${id}:`, error);
      // Potentially throw new Error(`Supabase error: ${error.message}`);
      return false;
    }
    return true;
  }

  // User specific methods
  async findUserByEmail(email: string): Promise<User | null> {
    const { data, error } = await this.client.from('users').select('*').eq('email', email).single();
    if (error && error.code !== 'PGRST116') {
        console.error('Error finding user by email:', error);
        throw new Error(`Supabase error: ${error.message}`);
    }
    return data ? mapSupabaseToUser(data) : null;
  }

  async createUser(userInput: InsertUser): Promise<User | null> {
    const supabaseInsertData = mapUserToSupabaseInsert(userInput);
    return this.create('users', supabaseInsertData);
  }

  async updateUser(id: string, userInput: Partial<UpdateUser | User>): Promise<User | null> {
    const supabaseUpdateData = mapUserToSupabaseUpdate(userInput);
    return this.update('users', id, supabaseUpdateData);
  }

  // Section specific methods
  async getSectionsByUserId(userId: string): Promise<Section[]> {
    return this.findAllByField('sections', 'user_id', userId);
  }

  async getSectionByType(userId: string, type: SectionType): Promise<Section | null> {
    const { data, error } = await this.client
      .from('sections')
      .select('*')
      .eq('user_id', userId)
      .eq('type', type as string)
      .maybeSingle(); // Use maybeSingle to handle 0 or 1 result gracefully

    if (error) {
      console.error(`Error finding section by type ${type} for user ${userId}:`, error);
      throw new Error(`Supabase error: ${error.message}`);
    }
    return data ? mapSupabaseToSection(data) : null;
  }
  
  async createSection(sectionInput: InsertSection): Promise<Section | null> {
    const supabaseInsertData = mapSectionToSupabaseInsert(sectionInput);
    return this.create('sections', supabaseInsertData);
  }

  async updateSection(id: number, sectionInput: UpdateSection): Promise<Section | null> {
    const supabaseUpdateData = mapSectionToSupabaseUpdate(sectionInput);
    return this.update('sections', id, supabaseUpdateData);
  }

  // Project specific methods
  async getProjectsByUserId(userId: string): Promise<Project[]> {
    return this.findAllByField('projects', 'user_id', userId);
  }

  async createProject(projectInput: InsertProject): Promise<Project | null> {
    const supabaseInsertData = mapProjectToSupabaseInsert(projectInput);
    return this.create('projects', supabaseInsertData);
  }

  async updateProject(id: string, projectInput: UpdateProject): Promise<Project | null> {
    const supabaseUpdateData = mapProjectToSupabaseUpdate(projectInput);
    return this.update('projects', id, supabaseUpdateData);
  }

  // Experience specific methods
  async getExperiencesByUserId(userId: string): Promise<Experience[]> {
    // As 'experiences' table doesn't have user_id, this method might need re-evaluation
    // For now, returning all experiences and then filtering client-side if needed, or assuming it's managed elsewhere.
    // OR, if it should fetch based on some other criteria linked to a user, that logic would go here.
    console.warn("'getExperiencesByUserId' called, but 'experiences' table has no 'user_id' column. Returning all experiences.");
    return this.findAll('experiences');
  }

  async createExperience(experienceInput: InsertExperience): Promise<Experience | null> {
    const supabaseInsertData = mapExperienceToSupabaseInsert(experienceInput);
    return this.create('experiences', supabaseInsertData);
  }

  async updateExperience(id: number, experienceInput: UpdateExperience): Promise<Experience | null> {
    const supabaseUpdateData = mapExperienceToSupabaseUpdate(experienceInput);
    return this.update('experiences', id, supabaseUpdateData);
  }

  // Certification specific methods
  async getCertificationsByUserId(userId: string): Promise<Certification[]> {
    return this.findAllByField('certifications', 'user_id', userId);
  }

  async createCertification(certificationInput: InsertCertification): Promise<Certification | null> {
    const supabaseInsertData = mapCertificationToSupabaseInsert(certificationInput);
    return this.create('certifications', supabaseInsertData);
  }

  async updateCertification(id: string, certificationInput: UpdateCertification): Promise<Certification | null> {
    const supabaseUpdateData = mapCertificationToSupabaseUpdate(certificationInput);
    return this.update('certifications', id, supabaseUpdateData);
  }
  
  // BlogCategory specific methods
  async getAllBlogCategories(): Promise<BlogCategory[]> {
    return this.findAll('blog_categories');
  }

  async getBlogCategoryBySlug(slug: string): Promise<BlogCategory | null> {
    const { data, error } = await this.client.from('blog_categories').select('*').eq('slug', slug).single();
    if (error && error.code !== 'PGRST116') {
      console.error('Error finding blog category by slug:', error);
      throw new Error(`Supabase error: ${error.message}`);
    }
    const mapper = getDomainMapper('blog_categories');
    return data && mapper ? mapper(data) : null;
  }

  async createBlogCategory(categoryInput: InsertBlogCategory): Promise<BlogCategory | null> {
    const supabaseInsertData = mapBlogCategoryToSupabaseInsert(categoryInput);
    return this.create('blog_categories', supabaseInsertData);
  }

  async updateBlogCategory(id: number, categoryInput: Partial<UpdateBlogCategory>): Promise<BlogCategory | null> {
    const supabaseUpdateData = mapBlogCategoryToSupabaseUpdate(categoryInput);
    return this.update('blog_categories', id, supabaseUpdateData);
  }

  // BlogPost specific methods
  async getAllBlogPosts(): Promise<BlogPost[]> {
    return this.findAll('blog_posts');
  }

  async getBlogPostBySlug(slug: string): Promise<BlogPost | null> {
    const { data, error } = await this.client.from('blog_posts').select('*').eq('slug', slug).single();
     if (error && error.code !== 'PGRST116') {
      console.error('Error finding blog post by slug:', error);
      throw new Error(`Supabase error: ${error.message}`);
    }
    const mapper = getDomainMapper('blog_posts');
    return data && mapper ? mapper(data) : null;
  }

  async getBlogPostsByCategory(categoryId: number): Promise<BlogPost[]> {
    return this.findAllByField('blog_posts', 'category_id', categoryId);
  }

  async createBlogPost(postInput: InsertBlogPost): Promise<BlogPost | null> {
    const supabaseInsertData = mapBlogPostToSupabaseInsert(postInput);
    return this.create('blog_posts', supabaseInsertData);
  }

  async updateBlogPost(id: number, postInput: UpdateBlogPost): Promise<BlogPost | null> {
    const supabaseUpdateData = mapBlogPostToSupabaseUpdate(postInput);
    return this.update('blog_posts', id, supabaseUpdateData);
  }

  // BlogSubscription specific methods
  async getBlogSubscriptionByEmail(email: string): Promise<BlogSubscription | null> {
    const { data, error } = await this.client.from('blog_subscriptions').select('*').eq('email', email).single();
    if (error && error.code !== 'PGRST116') {
      console.error('Error finding blog subscription by email:', error);
      throw new Error(`Supabase error: ${error.message}`);
    }
    const mapper = getDomainMapper('blog_subscriptions');
    return data && mapper ? mapper(data) : null;
  }

  async createBlogSubscription(subscriptionInput: InsertBlogSubscription): Promise<BlogSubscription | null> {
    const supabaseInsertData = mapBlogSubscriptionToSupabaseInsert(subscriptionInput);
    return this.create('blog_subscriptions', supabaseInsertData);
  }

  async updateBlogSubscription(id: number, subscriptionInput: UpdateBlogSubscription): Promise<BlogSubscription | null> {
    const supabaseUpdateData = mapBlogSubscriptionToSupabaseUpdate(subscriptionInput);
    return this.update('blog_subscriptions', id, supabaseUpdateData);
  }

  async deleteBlogSubscription(id: number): Promise<boolean> {
    return this.delete('blog_subscriptions', id);
  }
  
  // CaseStudyDetail specific methods
  async getCaseStudyDetailsByBlogPostId(blogPostId: number): Promise<CaseStudyDetail | null> {
    return this.findById('case_study_details', blogPostId); // Assuming ID matches blogPostId
  }

  async getAllCaseStudyDetails(): Promise<CaseStudyDetail[]> {
    return this.findAll('case_study_details');
  }

  async getCaseStudyDetailsBySlug(slug: string): Promise<CaseStudyDetail | null> {
    // Assuming 'slug' is a unique field in 'case_study_details'
    const { data, error } = await this.client.from('case_study_details').select('*').eq('slug', slug).single();
    if (error && error.code !== 'PGRST116') {
        console.error('Error finding case study detail by slug:', error);
        throw new Error(`Supabase error: ${error.message}`);
    }
    const mapper = getDomainMapper('case_study_details');
    return data && mapper ? mapper(data) : null;
  }

  async getCaseStudyDetailsByProjectType(projectType: string): Promise<CaseStudyDetail[]> {
    // Assuming 'project_type' is a field in 'case_study_details'
    return this.findAllByField('case_study_details', 'project_type' as any, projectType); // Cast field name if not strictly typed
  }

  async createCaseStudyDetail(detailInput: InsertCaseStudyDetail): Promise<CaseStudyDetail | null> {
    const supabaseInsertData = mapCaseStudyDetailToSupabaseInsert(detailInput);
    return this.create('case_study_details', supabaseInsertData);
  }

  async updateCaseStudyDetail(id: number, detailInput: Partial<UpdateCaseStudyDetail>): Promise<CaseStudyDetail | null> {
    const supabaseUpdateData = mapCaseStudyDetailToSupabaseUpdate(detailInput);
    return this.update('case_study_details', id, supabaseUpdateData);
  }

  async deleteCaseStudyDetail(id: number): Promise<boolean> {
    return this.delete('case_study_details', id);
  }

  // ContactSubmission specific methods
  async getContactSubmissionById(id: number): Promise<ContactSubmission | null> {
    return this.findById('contact_submissions', id);
  }

  async getAllContactSubmissions(): Promise<ContactSubmission[]> {
    return this.findAll('contact_submissions');
  }

  async createContactSubmission(submissionInput: InsertContactSubmission): Promise<ContactSubmission | null> {
    const supabaseInsertData = mapContactSubmissionToSupabaseInsert(submissionInput);
    return this.create('contact_submissions', supabaseInsertData);
  }

  async updateContactSubmissionStatus(id: number, status: string): Promise<ContactSubmission | null> {
    const supabaseUpdateData = mapContactSubmissionToSupabaseUpdate({ status });
    return this.update('contact_submissions', id, supabaseUpdateData);
  }

  // Add more specific methods for ContactSubmission as needed
  async updateContactSubmission(id: number, submissionInput: Partial<UpdateContactSubmission>): Promise<ContactSubmission | null> {
    const supabaseUpdateData = mapContactSubmissionToSupabaseUpdate(submissionInput);
    return this.update('contact_submissions', id, supabaseUpdateData);
  }

}
